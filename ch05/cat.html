<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ„ ç´” 3D è–èª•æ¨¹ (ç„¡éœ€æ”åƒé ­/MediaPipe)</title>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { position: absolute; width: 100%; height: 100%; }
        /* ç§»é™¤æ‰€æœ‰è¼‰å…¥ç•«é¢å’Œ UIï¼Œç›´æ¥å±•ç¤º 3D */
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        // å¼•å…¥ OrbitControlsï¼Œè®“æ‚¨å¯ä»¥ç”¨æ»‘é¼ æ—‹è½‰è¦–è§’
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; 
        
        // --- æ ¸å¿ƒé…ç½® ---
        const NUM_PARTICLES = 500;
        
        // --- å…¨å±€è®Šé‡ ---
        let scene, camera, renderer, controls;
        let particles = [];
        
        // --- è¼”åŠ©å‡½æ•¸ ---

        // èºæ—‹åœ“éŒé«”è–èª•æ¨¹å½¢ç‹€è¨ˆç®—
        function calculateTreePosition(index, total) {
            const height = 15;
            const baseRadius = 4;
            // è®“æ¨¹çœ‹èµ·ä¾†æ›´èŒ‚å¯†ï¼Œç¨å¾®æ”¹è®Šèºæ—‹åƒæ•¸
            const angle = index / total * Math.PI * 15; 
            const y = (index / total) * height - (height / 2) - 2; // èª¿æ•´åˆ° Y è»¸ä¸­å¿ƒ
            const r = baseRadius * (1 - index / total * 0.9); 
            
            return new THREE.Vector3(
                Math.cos(angle) * r,
                y,
                Math.sin(angle) * r
            );
        }

        // --- Three.js æ ¸å¿ƒåˆå§‹åŒ– ---

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111); // æ·±è‰²èƒŒæ™¯

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 15;
            camera.position.y = 3;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // å•Ÿç”¨æ»‘é¼ æ§åˆ¶
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // å•Ÿç”¨é˜»å°¼æ•ˆæœï¼Œè¦–è§’æ›´å¹³æ»‘
            
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ç²’å­ç³»çµ± (æ¨¹è‘‰/è£é£¾) å‰µå»º ---

        function createParticles() {
            // å‰µå»ºä¸€å€‹é€šç”¨æè³ª
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x00ff00, // ç¶ è‰²ç²’å­
                shininess: 80 // å¢åŠ å…‰æ¾¤
            });

            for (let i = 0; i < NUM_PARTICLES; i++) {
                // ä½¿ç”¨å…«é¢é«” (Octahedron) ä½œç‚ºç²’å­å½¢ç‹€ï¼Œçœ‹èµ·ä¾†åƒé–ƒçˆçš„è£é£¾
                const geometry = new THREE.OctahedronGeometry(0.2, 0); 
                
                const particle = new THREE.Mesh(geometry, material);
                
                // è¨­å®šç²’å­ä½ç½®ç‚ºè–èª•æ¨¹ä¸Šçš„ç›®æ¨™ä½ç½®
                const pos = calculateTreePosition(i, NUM_PARTICLES);
                particle.position.copy(pos);
                
                // å¢åŠ è£é£¾æ„Ÿï¼šéš¨æ©Ÿæ—‹è½‰
                particle.rotation.set(
                    Math.random() * Math.PI, 
                    Math.random() * Math.PI, 
                    Math.random() * Math.PI
                );
                
                particles.push(particle);
                scene.add(particle);
            }

            // æ·»åŠ é ‚éƒ¨æ˜Ÿæ˜Ÿ (æ›´å¤§çš„ç²’å­)
            const starGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700 }); // é‡‘è‰²
            const star = new THREE.Mesh(starGeometry, starMaterial);
            star.position.set(0, (15 / 2) - 2, 0); // æ¨¹é ‚ä½ç½®
            scene.add(star);
            
            // æ·»åŠ æ¨¹å¹¹
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 4, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 }); // æ£•è‰²
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(0, -5, 0);
            scene.add(trunk);
        }
        
        // --- ç‡ˆå…‰è¨­ç½® ---

        function setupLighting() {
            // ç’°å¢ƒå…‰
            scene.add(new THREE.AmbientLight(0xffffff, 0.5)); 
            
            // é»å…‰æºæ¨¡æ“¬ç‡ˆä¸²
            const pointLight = new THREE.PointLight(0xffffff, 200, 100);
            pointLight.position.set(0, 10, 5);
            scene.add(pointLight);
        }

        // --- ä¸»å¾ªç’° (Animate) ---

        function animate() {
            requestAnimationFrame(animate);

            // æ›´æ–° OrbitControls (æ»‘é¼ äº¤äº’)
            controls.update(); 
            
            // è®“ç²’å­æœ¬èº«è¼•å¾®æ—‹è½‰ï¼Œå¢åŠ é–ƒçˆæ„Ÿ
            particles.forEach(p => {
                p.rotation.y += 0.01;
                p.rotation.x += 0.005;
            });

            renderer.render(scene, camera);
        }
        
        // --- å•Ÿå‹•ç¨‹åº ---

        function main() {
            initThree();
            setupLighting();
            createParticles(); 
            animate();
        }

        main();

    </script>
</body>
</html>
