<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ„ 3D è–èª•ç…§ç‰‡ç‰† - MediaPipe äº¤äº’</title>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/vision_bundle.js"
            }
        }
    </script>

    <style>
        /* åŸºç¤æ¨£å¼ */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { position: absolute; width: 100%; height: 100%; }
        
        /* å·¦ä¸‹è§’ UI æŒ‰éˆ• */
        #ui-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .action-button {
            padding: 10px 18px;
            background-color: rgba(33, 150, 243, 0.85); /* è—è‰²ä¸»é¡Œ */
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
            font-weight: bold;
            color: #fff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s;
        }
        .action-button:hover { background-color: #1e88e5; }

        /* è¼‰å…¥å’ŒéŒ¯èª¤æç¤º */
        #loader, #error-message {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            color: #f0f0f0;
            display: flex; justify-content: center; align-items: center;
            font-size: 20px; flex-direction: column; text-align: center;
            z-index: 1000;
        }
        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #e74c3c; /* è–èª•ç´… */
            border-radius: 50%; width: 40px; height: 40px;
            animation: spin 1s linear infinite; margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hidden { display: none !important; }

        /* ç‹€æ…‹æŒ‡ç¤ºå™¨ */
        #state-indicator {
            position: absolute;
            top: 10px; right: 10px;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 10;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="state-indicator">ç•¶å‰ç‹€æ…‹: SCATTER</div>

    <div id="ui-overlay">
        <button class="action-button">æ·»åŠ ç…§ç‰‡</button>
        <button class="action-button">ç®¡ç†ç…§ç‰‡</button>
        <button class="action-button">æ·»åŠ éŸ³æ¨‚</button>
    </div>

    <div id="loader">
        <div class="spinner"></div>
        æ­£åœ¨è¼‰å…¥ 3D è³‡æºèˆ‡ AI æ¨¡å‹ï¼Œè«‹ç¨å€™...
    </div>

    <div id="error-message" class="hidden">
        âš ï¸ åˆå§‹åŒ–å¤±æ•—ã€‚è«‹ç¢ºèªæ”åƒé ­æ¬Šé™å·²è¢«å…è¨±ï¼Œä¸”æ‚¨æ­£åœ¨ä½¿ç”¨ HTTP(S) ç’°å¢ƒé‹è¡Œã€‚
    </div>

    <video id="webcam-video" style="display:none;" autoplay playsinline></video>

    <script type="module">
        import * as THREE from 'three';
        import { HandLandmarker, FilesetResolver } from '@mediapipe/tasks-vision';
        
        // --- æ ¸å¿ƒé…ç½® ---
        const NUM_PARTICLES = 100; // ç…§ç‰‡æ•¸é‡
        const ROTATION_COEFFICIENT = 1.2; // æ—‹è½‰é€Ÿåº¦ä¿‚æ•¸ (é˜²æ­¢æšˆçœ©)
        const LERP_FACTOR = 0.08; // ç²’å­å¹³æ»‘ç§»å‹•é€Ÿåº¦
        const FOCUS_MAGNIFICATION = 2.8; // èšç„¦æ”¾å¤§å€æ•¸
        const FOCUS_REGION_RADIUS = 0.55; // æ™ºèƒ½æŠ“å–åˆ¤å®šåŠå¾‘ (NDC æ­¸ä¸€åŒ–åº§æ¨™)
        
        // --- å…¨å±€ç‹€æ…‹ ---
        let scene, camera, renderer, video, handLandmarker;
        let photoParticles = [];
        let currentState = 'SCATTER'; 
        let focusedPhoto = null;
        let stateIndicator = document.getElementById('state-indicator');

        // --- è¼”åŠ©å‡½æ•¸ ---

        const loaderElement = document.getElementById('loader');
        const errorElement = document.getElementById('error-message');
        const updateStateIndicator = (state) => {
            stateIndicator.textContent = `ç•¶å‰ç‹€æ…‹: ${state}`;
        };

        function showLoader(visible = true) { loaderElement.classList.toggle('hidden', !visible); }
        function showError(message) {
            showLoader(false);
            errorElement.innerHTML = `âš ï¸ ${message}`;
            errorElement.classList.remove('hidden');
        }

        // --- Three.js æ ¸å¿ƒåˆå§‹åŒ– ---

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 8;
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            scene.add(new THREE.PointLight(0xffffff, 1.5).position.set(0, 5, 5));

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ç²’å­ç³»çµ± (ç…§ç‰‡) å‰µå»º ---

        function createPhotoParticles() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 128; tempCanvas.height = 128;
            const ctx = tempCanvas.getContext('2d');
            
            // å‰µå»ºä¸€å€‹ç°¡å–®çš„è–èª•ä¸»é¡Œç´‹ç† (ç¢ºä¿ä¸ä¾è³´å¤–éƒ¨è³‡æº)
            ctx.fillStyle = '#1e88e5'; // è—è‰²èƒŒæ™¯
            ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = '#f9f9f9';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('â­', 64, 64);
            
            const texture = new THREE.CanvasTexture(tempCanvas);

            for (let i = 0; i < NUM_PARTICLES; i++) {
                const geometry = new THREE.PlaneGeometry(1, 1);
                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    side: THREE.DoubleSide, 
                    transparent: true 
                });
                const photoMesh = new THREE.Mesh(geometry, material);
                
                // åˆå§‹éš¨æ©Ÿä½ç½® (ç”¨æ–¼ SCATTER ç‹€æ…‹)
                const randomPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );

                photoMesh.position.copy(randomPos);

                photoMesh.userData = {
                    scatterPos: randomPos,
                    treePos: calculateTreePosition(i, NUM_PARTICLES), 
                    initialScale: new THREE.Vector3(1, 1, 1),
                    targetPos: randomPos.clone(), // åˆå§‹ç›®æ¨™ç‚ºæ•£é–‹
                    targetScale: new THREE.Vector3(1, 1, 1),
                    isFocused: false
                };
                
                scene.add(photoMesh);
                photoParticles.push(photoMesh);
            }
        }
        
        // èºæ—‹åœ“éŒé«”è–èª•æ¨¹å½¢ç‹€è¨ˆç®—
        function calculateTreePosition(index, total) {
            const height = 15;
            const baseRadius = 5;
            const angle = index / total * Math.PI * 10; // 10 åœˆèºæ—‹
            const y = (index / total) * height - (height / 2);
            const r = baseRadius * (1 - index / total * 0.8); // åŠå¾‘éš¨é«˜åº¦éæ¸›
            
            return new THREE.Vector3(
                Math.cos(angle) * r,
                y,
                Math.sin(angle) * r
            );
        }

        // --- MediaPipe åˆå§‹åŒ–èˆ‡æ‰‹å‹¢é‚è¼¯ ---

        async function initMediaPipe() {
            const filesetResolver = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
            );
            
            // æ³¨æ„: ä½¿ç”¨ CDN æä¾›çš„æ¨¡å‹è·¯å¾‘ï¼Œç¢ºä¿ç©©å®šæ€§
            handLandmarker = await HandLandmarker.create(filesetResolver, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU" 
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            // ç²å–æ”åƒé ­è¦–é »æµ
            video = document.getElementById('webcam-video');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            
            return new Promise((resolve) => {
                video.onloadeddata = () => {
                    video.play();
                    showLoader(false); // éš±è—è¼‰å…¥ç•«é¢
                    resolve();
                };
            });
        }
        

        let lastHandPos = new THREE.Vector2(0.5, 0.5); // ç´€éŒ„ä¸Šæ¬¡æ‰‹éƒ¨ä½ç½® (NDC)

        function detectHand() {
            if (handLandmarker && video.readyState >= 2) { // ä½¿ç”¨ readyState åˆ¤æ–·è¦–é »æ˜¯å¦æº–å‚™å¥½
                handLandmarker.detectForVideo(video, performance.now(), onHandResults);
            }
        }

        /**
         * ç©©å®šæ‰‹å‹¢åˆ¤å®šå‡½æ•¸
         * @param {Array<THREE.Vector3>} landmarks - æ­¸ä¸€åŒ–åº§æ¨™é» (0åˆ°1)
         */
        function determineHandGesture(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const wrist = landmarks[0];

            // 1. æåˆ (FOCUS) åˆ¤å®š: æ‹‡æŒ‡å°–èˆ‡é£ŸæŒ‡å°–è·é›¢
            const pinchDistance = thumbTip.distanceTo(indexTip);
            if (pinchDistance < 0.03) { 
                return 'FOCUS';
            }
            
            // 2. æ¡æ‹³ (TREE) åˆ¤å®š: é£ŸæŒ‡å°–èˆ‡è…•éƒ¨è·é›¢
            const maxFingerWristDistance = indexTip.distanceTo(wrist);
            
            if (maxFingerWristDistance < 0.15) { // å‡è¨­æŒ‡å°–é è¿‘æŒå¿ƒ
                return 'TREE';
            }

            // 3. å¼µé–‹ (SCATTER) åˆ¤å®š: é è¨­ç‹€æ…‹
            return 'SCATTER';
        }
        
        function onHandResults(result) {
            const landmarks = result.landmarks?.[0];

            if (landmarks) {
                // ç´€éŒ„æ‰‹éƒ¨ä¸­å¿ƒ (ä½¿ç”¨é» 0 - è…•éƒ¨)
                lastHandPos.set(landmarks[0].x, 1 - landmarks[0].y); // Yè»¸åè½‰ (MediaPipe åæ¨™ç³» vs å±å¹•åæ¨™ç³»)
                
                const newState = determineHandGesture(landmarks);
                
                if (newState !== currentState) {
                    currentState = newState;
                    
                    // åŸ·è¡Œç‹€æ…‹åˆ‡æ›å‹•ä½œ
                    if (currentState === 'TREE') {
                        resetFocusedPhoto();
                        updateParticlesTargetToTree();
                    } else if (currentState === 'SCATTER') {
                        resetFocusedPhoto(); 
                        updateParticlesTargetToRandom();
                    }
                }
                
                updateStateIndicator(currentState);

                // è™•ç†æŒçºŒæ€§ç‹€æ…‹äº¤äº’
                if (currentState === 'SCATTER') {
                    applyEdgeRotation();
                } else if (currentState === 'FOCUS') {
                    focusOnNearestPhoto();
                }
                
            } else {
                // å¦‚æœæ‰‹å‹¢æ¶ˆå¤±ï¼Œä¸”ç›®å‰æ˜¯ FOCUS ç‹€æ…‹ï¼Œå‰‡é‡‹æ”¾ç…§ç‰‡
                if (currentState === 'FOCUS') {
                     resetFocusedPhoto();
                     currentState = 'SCATTER'; // æ¢å¾©åˆ°æ•£é–‹ç‹€æ…‹
                     updateStateIndicator(currentState);
                }
                // æ‰‹éƒ¨ä¸åœ¨è¢å¹•ä¸Šæ™‚ï¼Œæ—‹è½‰ç·©æ…¢åœæ­¢
                scene.rotation.y *= 0.98; 
            }
        }

        // --- äº¤äº’åŠŸèƒ½å¯¦ç¾ ---

        function updateParticlesTargetToTree() {
            photoParticles.forEach(p => p.userData.targetPos.copy(p.userData.treePos));
        }

        function updateParticlesTargetToRandom() {
            photoParticles.forEach(p => p.userData.targetPos.copy(p.userData.scatterPos));
        }

        function applyEdgeRotation() {
            // è¨ˆç®—æ‰‹éƒ¨ä¸­å¿ƒåˆ°å±å¹•ä¸­å¿ƒçš„è·é›¢ (æ­¸ä¸€åŒ–åº§æ¨™ 0åˆ°1)
            // lastHandPos.x æ˜¯ [0, 1]ï¼Œä¸­å¿ƒé»æ˜¯ 0.5
            const dx = lastHandPos.x - 0.5;
            const dy = lastHandPos.y - 0.5; 
            
            const distance = Math.sqrt(dx * dx + dy * dy); 
            
            // æ—‹è½‰é€Ÿåº¦ï¼šè·é›¢è¶Šé ï¼Œé€Ÿåº¦è¶Šå¿« (ä¹˜ä»¥ä¿‚æ•¸ 1.2)
            const rotationSpeed = distance * ROTATION_COEFFICIENT * 0.05; 
            
            // æ‡‰ç”¨æ—‹è½‰ (ä»¥ Y è»¸ç‚ºä¸»)
            scene.rotation.y += rotationSpeed * (dx > 0 ? 1 : -1); 
        }

        function focusOnNearestPhoto() {
            if (focusedPhoto && focusedPhoto.userData.isFocused) {
                // å¦‚æœå·²ç¶“é–å®šï¼Œå‰‡ä¸é‡æ–°è¨ˆç®—ï¼Œç›´åˆ°é‡‹æ”¾
                return; 
            }
            
            let nearestDistance = Infinity;
            let candidatePhoto = null;

            photoParticles.forEach(p => {
                // 1. å–å¾—ç…§ç‰‡åœ¨ 3D ç©ºé–“ä¸­çš„ä½ç½®ï¼Œä¸¦æŠ•å½±åˆ° 2D å±å¹• (NDC æ­¸ä¸€åŒ–åº§æ¨™)
                const vector = p.position.clone().project(camera); 
                
                // 2. è½‰æ› NDC åº§æ¨™ [-1, 1] åˆ° [0, 1] æ–¹ä¾¿èˆ‡æ‰‹éƒ¨åº§æ¨™æ¯”è¼ƒ
                const projectedX = (vector.x + 1) / 2;
                const projectedY = (vector.y + 1) / 2;
                
                // 3. è¨ˆç®—ç…§ç‰‡åˆ°å±å¹•ä¸­å¿ƒçš„ 2D è·é›¢
                const distToCenter = Math.sqrt(
                    Math.pow(projectedX - 0.5, 2) + Math.pow(projectedY - 0.5, 2)
                ); 

                // 4. åˆ¤æ–·æ˜¯å¦åœ¨åˆ¤å®šåŠå¾‘å…§ï¼Œä¸¦æ‰¾åˆ°æœ€è¿‘çš„ä¸€å¼µ
                if (distToCenter < FOCUS_REGION_RADIUS) {
                    if (distToCenter < nearestDistance) {
                        nearestDistance = distToCenter;
                        candidatePhoto = p;
                    }
                }
            });

            if (candidatePhoto) {
                focusedPhoto = candidatePhoto;
                focusedPhoto.userData.isFocused = true;
                
                // è¨ˆç®—ç›®æ¨™ä½ç½®: ç›¸æ©Ÿå‰æ–¹ 2 å–®ä½è™•
                const focusTargetPos = new THREE.Vector3(0, 0, -2);
                focusTargetPos.applyMatrix4(camera.matrixWorld); // è½‰æ›åˆ°ä¸–ç•Œåº§æ¨™
                
                focusedPhoto.userData.targetPos.copy(focusTargetPos);
                focusedPhoto.userData.targetScale.set(FOCUS_MAGNIFICATION, FOCUS_MAGNIFICATION, FOCUS_MAGNIFICATION);
                
                // ç¢ºä¿èšç„¦ç…§ç‰‡é¢å‘é¡é ­
                focusedPhoto.lookAt(camera.position);
            }
        }
        
        function resetFocusedPhoto() {
            if (focusedPhoto) {
                // æ­¸ä½åˆ°ç•¶å‰ç‹€æ…‹ä¸‹çš„åŸå§‹ç›®æ¨™
                const resetPos = (currentState === 'TREE') ? focusedPhoto.userData.treePos : focusedPhoto.userData.scatterPos;
                
                focusedPhoto.userData.targetPos.copy(resetPos);
                focusedPhoto.userData.targetScale.copy(focusedPhoto.userData.initialScale);

                focusedPhoto.userData.isFocused = false;
                focusedPhoto = null;
            }
        }
        
        // --- ä¸»å¾ªç’° (Animate) ---

        function animate() {
            requestAnimationFrame(animate);

            // ç²’å­å¹³æ»‘éæ¸¡
            updateParticles();
            
            // å¯¦æ™‚æ‰‹å‹¢æª¢æ¸¬ (ç¢ºä¿åœ¨ requestAnimationFrame å…§èª¿ç”¨)
            detectHand();
            
            renderer.render(scene, camera);
        }
        
        function updateParticles() {
            photoParticles.forEach(p => {
                // å¹³æ»‘ç§»å‹• (Lerp)
                p.position.lerp(p.userData.targetPos, LERP_FACTOR);
                p.scale.lerp(p.userData.targetScale, LERP_FACTOR);
                
                // éèšç„¦ç‹€æ…‹ä¸‹ï¼Œè®“ç…§ç‰‡é¢å‘æ”åƒæ©Ÿ
                if (!p.userData.isFocused) {
                    p.lookAt(camera.position); 
                }
            });
        }

        // --- å•Ÿå‹•ç¨‹åº ---

        async function main() {
            showLoader();
            try {
                initThree();
                createPhotoParticles(); 
                
                await initMediaPipe();
                
                animate();

            } catch (e) {
                console.error("åˆå§‹åŒ–å¤±æ•—:", e);
                // æç¤ºç”¨æˆ¶æª¢æŸ¥æ¬Šé™ï¼Œè€Œä¸æ˜¯ç›´æ¥æ‹‹å‡ºéŒ¯èª¤
                showError("ç„¡æ³•åˆå§‹åŒ–ã€‚è«‹ç¢ºèªï¼š1. ç€è¦½å™¨å…è¨±æ”åƒé ­æ¬Šé™ã€‚ 2. æ‚¨åœ¨ HTTP/HTTPS ç’°å¢ƒä¸­é‹è¡Œã€‚");
            }
        }

        main();

    </script>
</body>
</html>
