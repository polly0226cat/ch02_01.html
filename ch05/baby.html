<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘</title>
    <style>
        /* --------------------
           CSS æ ·å¼
           -------------------- */
        body { margin: 0; overflow: hidden; background-color: #0d0d0d; }
        canvas { display: block; }
        #overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
        }
        #hand-state {
            margin-top: 5px;
            font-weight: bold;
            color: gold;
        }
        #upload-container {
            margin-top: 10px;
        }
        input[type="file"] {
            display: none;
        }
        .custom-file-upload {
            border: 1px solid gold;
            display: inline-block;
            padding: 6px 12px;
            cursor: pointer;
            background-color: rgba(255, 215, 0, 0.1);
            color: gold;
            border-radius: 3px;
            font-size: 0.9em;
        }
        #video-feedback {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 150px;
            height: 112px; /* 4:3 æ¯”ä¾‹ */
            z-index: 100;
            border: 2px solid gold;
            transform: scaleX(-1); /* é•œåƒ */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body>
    <div id="overlay">
        <h3>ğŸ„ æ‰‹åŠ¿æ§åˆ¶åœ£è¯æ ‘ ğŸŒŸ</h3>
        <p>çŠ¶æ€ï¼š<span id="scene-state">åˆæ‹¢æ€</span></p>
        <p>æ‰‹åŠ¿ï¼š<span id="hand-state">æœªæ£€æµ‹åˆ°æ‰‹åŠ¿</span></p>
        <ul>
            <li>**æ¡æ‹³ (Fist):** â†’ åˆæ‹¢æ€ (Cone)</li>
            <li>**äº”æŒ‡å¼ å¼€ (Open Palm):** â†’ æ•£å¼€æ€ (Scatter)</li>
            <li>**æ—‹è½¬/ç§»åŠ¨æ‰‹:** â†’ æ•£å¼€æ€æ—¶æ—‹è½¬ç”»é¢ (Rotation)</li>
            <li>**æŠ“å– (Pinch/Grab):** â†’ ç…§ç‰‡æ”¾å¤§æ€ (Focus Photo)</li>
        </ul>
        <div id="upload-container">
            <label for="photo-upload" class="custom-file-upload">
                ä¸Šä¼ ç…§ç‰‡ (JPG/PNG)
            </label>
            <input type="file" id="photo-upload" accept="image/*" multiple>
            <p style="font-size:0.8em; margin: 5px 0 0 0;">(åˆå§‹æœ‰é»˜è®¤ç…§ç‰‡)</p>
        </div>
    </div>
    <video id="video-feedback" playsinline></video>

    <script>
        // --------------------
        // JavaScript é€»è¾‘
        // --------------------

        // --- 1. å¸¸é‡å’Œé…ç½® ---
        const NUM_ELEMENTS = 1500; // ç²’å­æ€»æ•°
        const NUM_PHOTOS = 12;     // ç…§ç‰‡æ•°é‡ (å°†å æ®å‰12ä¸ªå…ƒç´ )
        const STATE = {
            CONE: 'CONE',      // åˆæ‹¢æ€
            SCATTER: 'SCATTER', // æ•£å¼€æ€
            FOCUS: 'FOCUS'      // ç…§ç‰‡æ”¾å¤§æ€
        };

        // é¢œè‰²é…ç½®
        const COLORS = {
            GREEN: new THREE.Color(0x286b28),    // å“‘å…‰ç»¿
            GOLD: new THREE.Color(0xd4af37),     // é‡‘å±é‡‘
            RED: new THREE.Color(0xcc3333),      // åœ£è¯çº¢
            WHITE: new THREE.Color(0xf0f0f0)     // ç™½è‰²
        };

        // å…ƒç´ ç±»å‹
        const ELEMENT_TYPES = {
            SPHERE: 0,
            CUBE: 1,
            CANDY: 2,
            PHOTO: 3
        };

        // --- 2. çŠ¶æ€å˜é‡ ---
        let renderer, scene, camera, composer;
        let elementsMesh, photoMesh;
        let positions = [];      // ç›®æ ‡ä½ç½®
        let currentPositions = []; // å½“å‰ä½ç½®
        let rotations = [];      // éšæœºæ—‹è½¬
        let instanceData = [];   // å®ä¾‹æ•°æ® (é¢œè‰², ç±»å‹)
        let state = STATE.CONE;
        let targetState = STATE.CONE;
        let transitionTime = 0;
        let focusedPhotoIndex = -1;

        // æ‰‹åŠ¿ç›¸å…³
        let videoElement;
        let hands;
        let lastHandLandmarks = null;
        let handClosed = false;
        let handOpen = false;
        let handPinching = false;
        let handRotating = false;
        let lastHandX = 0;
        let lastHandY = 0;
        let cameraTarget = new THREE.Vector3(0, 0, 0);
        let cameraRotationDamping = 0.95;
        let cameraRotationVelocity = new THREE.Vector2(0, 0);

        // --- 3. åˆå§‹åŒ–å‡½æ•° ---

        /**
         * åˆå§‹åŒ– Three.js åœºæ™¯ã€ç›¸æœºå’Œæ¸²æŸ“å™¨
         */
        function initThree() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d0d, 0.005);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 20);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            // å…‰æº
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            // åæœŸå¤„ç†ï¼šè¾‰å…‰/å…‰æ™•æ•ˆæœ (Unreal Bloom Pass)
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.8, // Strength å¼ºåº¦
                0.4, // Radius åŠå¾„
                0.8  // Threshold é˜ˆå€¼ (ä½äºæ­¤äº®åº¦çš„ä¸è¾‰å…‰)
            );
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize);
        }

        /**
         * åˆ›å»º GLSL ç€è‰²å™¨æè´¨
         */
        function createInstancedMaterial(isPhoto = false) {
            const vertexShader = `
                precision highp float;
                // Instance Attributes
                attribute vec3 instancePosition; // ç›®æ ‡ä½ç½®
                attribute vec4 instanceRotation; // å››å…ƒæ•°æ—‹è½¬
                attribute vec3 instanceColor;
                attribute float instanceType;
                attribute float instanceTextureIndex; // ç…§ç‰‡ç´¢å¼•

                uniform float u_time;
                uniform float u_transitionTime; // 0 (å½“å‰) to 1 (ç›®æ ‡)
                uniform float u_maxTransitionTime; // æ€»è¿‡æ¸¡æ—¶é—´
                uniform float u_scatterRadius; // æ•£å¼€åŠå¾„
                uniform float u_focusIndex;    // èšç„¦ç…§ç‰‡ç´¢å¼•
                uniform mat4 u_modelMatrix; // æ¨¡å‹çš„æœ¬åœ°çŸ©é˜µ (ç”¨äºç…§ç‰‡)

                varying vec3 vColor;
                varying float vType;
                varying vec2 vUv;

                // é¢œè‰²å¹³æ»‘æ’å€¼å‡½æ•°
                vec3 smoothColor(vec3 c1, vec3 c2, float t) {
                    return mix(c1, c2, smoothstep(0.0, 1.0, t));
                }

                void main() {
                    vUv = uv;
                    vType = instanceType;

                    vec3 currentPos;
                    // ä½¿ç”¨ instanceMatrix (æœ¬åœ°è½¬æ¢çŸ©é˜µ) ä½œä¸ºå½“å‰ä½ç½®
                    vec4 currentPosition = instanceMatrix * vec4(position, 1.0);
                    currentPos = currentPosition.xyz;

                    // 1. åˆæ‹¢æ€ (Cone) ç›®æ ‡ä½ç½®
                    vec3 conePos;
                    float r = sqrt(instanceId) * 0.2; // èºæ—‹åŠå¾„
                    float a = instanceId * 0.25;       // èºæ—‹è§’åº¦
                    float y = instanceId * 0.2 + 0.1; // é«˜åº¦
                    conePos.x = r * cos(a);
                    conePos.y = y;
                    conePos.z = r * sin(a);

                    // 2. æ•£å¼€æ€ (Scatter) ç›®æ ‡ä½ç½®
                    vec3 scatterPos = instancePosition; // é¢„å…ˆè®¡ç®—çš„éšæœºç›®æ ‡

                    // 3. ç…§ç‰‡æ”¾å¤§æ€ (Focus) ç›®æ ‡ä½ç½®
                    vec3 focusPos = scatterPos;
                    if (vType == ${ELEMENT_TYPES.PHOTO}.0 && instanceId == u_focusIndex) {
                        focusPos = vec3(0.0, 0.0, 5.0); // èšç„¦åˆ°ç›¸æœºå‰
                    }

                    // æ ¹æ®è¿‡æ¸¡æ—¶é—´åœ¨å½“å‰ä½ç½®ã€åˆæ‹¢ã€æ•£å¼€å’Œèšç„¦ä½ç½®ä¹‹é—´æ’å€¼
                    vec3 targetPos = conePos;

                    if (u_transitionTime > 0.0) {
                        float t = u_transitionTime / u_maxTransitionTime; // å¹³æ»‘æ’å€¼å› å­

                        if (instanceId == u_focusIndex && vType == ${ELEMENT_TYPES.PHOTO}.0) {
                            // ç…§ç‰‡èšç„¦è¿‡æ¸¡: ä»å½“å‰ä½ç½® -> èšç„¦ä½ç½®
                             targetPos = focusPos;
                             currentPos = instancePosition; // ç…§ç‰‡æ”¾å¤§æ˜¯ä»æ•£å¼€æ€çš„ä½ç½®å¼€å§‹
                        } else if (u_transitionTime < u_maxTransitionTime) {
                            // å¸¸è§„è¿‡æ¸¡: ä»å½“å‰ä½ç½® -> ç›®æ ‡ä½ç½® (åˆæ‹¢æˆ–æ•£å¼€)
                             if (targetState == ${STATE.CONE.charCodeAt(0)}) {
                                 targetPos = conePos;
                             } else { // SCATTER
                                 targetPos = scatterPos;
                             }
                        } else {
                            // è¿‡æ¸¡ç»“æŸï¼Œä¿æŒç›®æ ‡çŠ¶æ€ä½ç½®
                            if (targetState == ${STATE.CONE.charCodeAt(0)}) {
                                targetPos = conePos;
                            } else { // SCATTER
                                targetPos = scatterPos;
                            }
                        }

                        // æœ€ç»ˆä½ç½®æ’å€¼
                        currentPos = mix(currentPos, targetPos, t);
                    } else {
                         // ç¨³å®šçŠ¶æ€
                         if (state == ${STATE.CONE.charCodeAt(0)}) {
                             currentPos = conePos;
                         } else { // SCATTER æˆ– FOCUS
                             if (instanceId == u_focusIndex && vType == ${ELEMENT_TYPES.PHOTO}.0) {
                                 currentPos = focusPos;
                             } else {
                                 currentPos = scatterPos;
                             }
                         }
                    }

                    // æ—‹è½¬ (ä¿æŒéšæœºæ—‹è½¬)
                    mat4 rotationMatrix = mat4(
                        1.0 - 2.0 * (instanceRotation.y * instanceRotation.y + instanceRotation.z * instanceRotation.z),
                        2.0 * (instanceRotation.x * instanceRotation.y - instanceRotation.w * instanceRotation.z),
                        2.0 * (instanceRotation.x * instanceRotation.z + instanceRotation.w * instanceRotation.y),
                        0.0,
                        2.0 * (instanceRotation.x * instanceRotation.y + instanceRotation.w * instanceRotation.z),
                        1.0 - 2.0 * (instanceRotation.x * instanceRotation.x + instanceRotation.z * instanceRotation.z),
                        2.0 * (instanceRotation.y * instanceRotation.z - instanceRotation.w * instanceRotation.x),
                        0.0,
                        2.0 * (instanceRotation.x * instanceRotation.z - instanceRotation.w * instanceRotation.y),
                        2.0 * (instanceRotation.y * instanceRotation.z + instanceRotation.w * instanceRotation.x),
                        1.0 - 2.0 * (instanceRotation.x * instanceRotation.x + instanceRotation.y * instanceRotation.y),
                        0.0,
                        0.0, 0.0, 0.0, 1.0
                    );

                    // åº”ç”¨å¹³ç§»ã€æ—‹è½¬ã€ç¼©æ”¾
                    mat4 finalTransform = mat4(
                        vec4(rotationMatrix[0].xyz * 0.5, 0.0), // ç¼©å°å°ºå¯¸
                        vec4(rotationMatrix[1].xyz * 0.5, 0.0),
                        vec4(rotationMatrix[2].xyz * 0.5, 0.0),
                        vec4(currentPos, 1.0)
                    );

                    gl_Position = projectionMatrix * viewMatrix * finalTransform * vec4(position, 1.0);

                    // é¢œè‰²å¤„ç†ï¼šæ·»åŠ é—ªçƒæ•ˆæœ (ä»…å¯¹éç…§ç‰‡å…ƒç´ )
                    if (vType != ${ELEMENT_TYPES.PHOTO}.0) {
                        float flicker = sin(u_time * 5.0 + instanceId * 0.5) * 0.1 + 0.9;
                        vColor = instanceColor * flicker;
                    } else {
                        vColor = instanceColor; // ç…§ç‰‡çš„é¢œè‰²ä¿æŒç™½è‰²
                    }

                    // ç›¸æœºæ—‹è½¬æ ¡æ­£ï¼ˆåœ¨æ•£å¼€æ€æ—¶ï¼Œéœ€è¦æ›´æ–°å½“å‰ä½ç½®ï¼‰
                    // è¿™ä¸€æ­¥åœ¨ CPU ä¸­é€šè¿‡ cameraTarget æ¥å®ç°ï¼Œé¿å…åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­è¿›è¡Œå¤æ‚çš„è§†å›¾çŸ©é˜µä¿®æ”¹
                }
            `;

            const fragmentShader = isPhoto ? `
                uniform sampler2D u_photoTexture;
                uniform float u_textureIndex;
                uniform float u_photoCount;
                varying vec3 vColor;
                varying float vType;
                varying vec2 vUv;
                
                void main() {
                    // ä»…æ¸²æŸ“ç…§ç‰‡å…ƒç´ 
                    if (vType == ${ELEMENT_TYPES.PHOTO}.0) {
                        // ä½¿ç”¨ vUv ç›´æ¥é‡‡æ ·çº¹ç†
                        gl_FragColor = texture2D(u_photoTexture, vUv);
                        // ä¸ºç…§ç‰‡æ·»åŠ ä¸€ä¸ªæŸ”å’Œçš„ç™½è‰²è¾¹æ¡†æ•ˆæœ
                        float borderFactor = 1.0 - (abs(vUv.x - 0.5) * 2.0 + abs(vUv.y - 0.5) * 2.0) * 0.05;
                        gl_FragColor.rgb *= borderFactor;
                    } else {
                        discard; // ä¸¢å¼ƒéç…§ç‰‡å…ƒç´ 
                    }
                }
            ` : `
                precision highp float;
                varying vec3 vColor;
                varying float vType;

                void main() {
                    // æ¸²æŸ“éç…§ç‰‡å…ƒç´  (Sphere, Cube, Candy)
                    if (vType != ${ELEMENT_TYPES.PHOTO}.0) {
                        // åŸºäºç±»å‹å®ç°ä¸åŒçš„è´¨æ„Ÿ
                        vec3 finalColor = vColor;
                        if (vType == ${ELEMENT_TYPES.CUBE}.0) {
                            // ç«‹æ–¹ä½“ï¼šå“‘å…‰ç»¿
                            finalColor = mix(finalColor, vec3(${COLORS.GREEN.r.toFixed(3)}, ${COLORS.GREEN.g.toFixed(3)}, ${COLORS.GREEN.b.toFixed(3)}), 0.8);
                        } else if (vType == ${ELEMENT_TYPES.SPHERE}.0) {
                            // çƒä½“ï¼šé‡‘å±é‡‘
                            finalColor = mix(finalColor, vec3(${COLORS.GOLD.r.toFixed(3)}, ${COLORS.GOLD.g.toFixed(3)}, ${COLORS.GOLD.b.toFixed(3)}), 0.8);
                        } else if (vType == ${ELEMENT_TYPES.CANDY}.0) {
                            // ç³–æœæ£ï¼šåœ£è¯çº¢/ç™½
                            finalColor = mix(finalColor, vec3(${COLORS.RED.r.toFixed(3)}, ${COLORS.RED.g.toFixed(3)}, ${COLORS.RED.b.toFixed(3)}), 0.8);
                        }

                        // ç®€å•çš„ç¯å…‰/åå°„æ•ˆæœï¼ˆæé«˜é«˜çº§æ„Ÿï¼‰
                        vec3 normal = normalize(gl_FragCoord.xyz);
                        float light = dot(normal, normalize(vec3(1.0, 1.0, 1.0))) * 0.5 + 0.5;
                        gl_FragColor = vec4(finalColor * light, 1.0);
                    } else {
                        discard; // ä¸¢å¼ƒç…§ç‰‡å…ƒç´  (ç”±å¦ä¸€ä¸ª Mesh æ¸²æŸ“)
                    }
                }
            `;

            const uniforms = {
                u_time: { value: 0 },
                u_transitionTime: { value: 0 },
                u_maxTransitionTime: { value: 1.0 },
                u_scatterRadius: { value: 20 },
                u_focusIndex: { value: -1 },
                u_photoTexture: { value: null }, // ä»…ç”¨äºç…§ç‰‡æè´¨
                u_photoCount: { value: NUM_PHOTOS } // ä»…ç”¨äºç…§ç‰‡æè´¨
            };

            return new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.DoubleSide,
                transparent: false,
                lights: false,
                wireframe: false
            });
        }

        /**
         * åŠ è½½ç…§ç‰‡çº¹ç†
         * @param {string[]} urls - ç…§ç‰‡ URL æ•°ç»„
         */
        function loadPhotoTextures(urls) {
            const textureLoader = new THREE.TextureLoader();
            const textures = [];

            // ç¡®ä¿è‡³å°‘æœ‰ NUM_PHOTOS ä¸ªå…ƒç´ ï¼Œä¸è¶³æ—¶ä½¿ç”¨é»˜è®¤çº¹ç†
            const defaultTexture = new THREE.TextureLoader().load('https://picsum.photos/256/256'); // é»˜è®¤å ä½å›¾

            for (let i = 0; i < NUM_PHOTOS; i++) {
                if (urls[i]) {
                    textures.push(textureLoader.load(urls[i], (texture) => {
                        texture.minFilter = THREE.LinearFilter;
                        texture.magFilter = THREE.LinearFilter;
                    }));
                } else {
                    textures.push(defaultTexture.clone());
                }
            }

            // åˆ›å»ºä¸€ä¸ªçº¹ç†å›¾é›† (Texture Atlas) æˆ–ä½¿ç”¨ Array Texture (æ›´å¤æ‚ï¼Œè¿™é‡Œç”¨ç®€å•çš„å•çº¹ç†å¤„ç†)
            // ç®€å•å¤„ç†: æ‰€æœ‰çš„ç…§ç‰‡éƒ½ä½¿ç”¨ä¸€ä¸ªçº¹ç†ï¼Œä½†å®é™…æ¸²æŸ“æ—¶ï¼Œåªèƒ½æ˜¾ç¤ºä¸€å¼ ç…§ç‰‡ï¼Œ
            // ä¸ºäº†å®ç°ç…§ç‰‡äº‘ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨å•ç‹¬çš„ InstancedMesh æ¥å¤„ç†ç…§ç‰‡ï¼Œå¹¶ä¸ºæ¯ä¸ªå®ä¾‹è®¾ç½®ä¸åŒçš„çº¹ç†åç§»ã€‚
            // ç”±äº Three.js InstancedMesh æ— æ³•ç›´æ¥ä¸ºæ¯ä¸ªå®ä¾‹è®¾ç½®ä¸åŒçš„ `map` çº¹ç†ï¼Œ
            // æœ€ç®€å•çš„æ–¹æ¡ˆæ˜¯ä½¿ç”¨ä¸€ä¸ª InstancedMesh æ¸²æŸ“æ‰€æœ‰ **éç…§ç‰‡** å…ƒç´ ï¼Œ
            // å¦ä¸€ä¸ª InstancedMesh æ¸²æŸ“æ‰€æœ‰ **ç…§ç‰‡** å…ƒç´ ï¼Œç…§ç‰‡å…ƒç´ ä½¿ç”¨ UV åç§»æˆ– Texture Arrayã€‚
            // é‰´äºå•æ–‡ä»¶åº”ç”¨çš„é™åˆ¶ï¼Œæˆ‘ä»¬è®©æ‰€æœ‰ç…§ç‰‡å®ä¾‹å…±äº«ä¸€ä¸ª *ç…§ç‰‡çº¹ç†å›¾é›†* æˆ–ç”¨ä¸€ä¸ªå•ç‹¬çš„ Photo-Plane Meshã€‚

            // ç®€åŒ–å¤„ç†ï¼šPhotos å®ä¾‹å…±äº«ä¸€ä¸ªé»˜è®¤çº¹ç†ï¼Œå¹¶åœ¨ Fragment Shader ä¸­æ¨¡æ‹Ÿç…§ç‰‡äº‘çš„é¢œè‰²ã€‚
            // ä¸ºäº†å®ç°ç‹¬ç«‹ç…§ç‰‡æ˜¾ç¤ºï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ **Texture Array** æˆ– **InstancedBufferAttribute** ä¼ é€’ç…§ç‰‡ç´¢å¼•ã€‚
            // æœ€ç®€å•çš„æ–¹å¼: å°†æ‰€æœ‰ç…§ç‰‡å®ä¾‹è§†ä¸ºç‹¬ç«‹ Meshï¼Œæˆ–è€…ä½¿ç”¨ä¸€ä¸ª InstancedMeshï¼Œä½†åªæ¸²æŸ“ NUM_PHOTOS ä¸ªå®ä¾‹ã€‚

            // ä¸ºäº†å®ç°ä¸åŒç…§ç‰‡çš„æ˜¾ç¤ºï¼Œæˆ‘ä»¬åˆ›å»ºä¸€ä¸ª **Texture Atlas** (å°†æ‰€æœ‰ç…§ç‰‡æ‹¼æ¥åˆ°ä¸€ä¸ªå¤§çº¹ç†ä¸­)
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const PHOTO_SIZE = 256;
            const COLS = Math.ceil(Math.sqrt(NUM_PHOTOS));
            const ROWS = Math.ceil(NUM_PHOTOS / COLS);
            canvas.width = COLS * PHOTO_SIZE;
            canvas.height = ROWS * PHOTO_SIZE;

            const photoAtlas = new THREE.CanvasTexture(canvas);

            let loadedCount = 0;
            const onPhotoLoad = () => {
                loadedCount++;
                if (loadedCount === textures.length) {
                    // æ‰€æœ‰ç…§ç‰‡åŠ è½½å®Œæˆï¼Œå¼€å§‹ç»˜åˆ¶å›¾é›†
                    textures.forEach((texture, index) => {
                        const col = index % COLS;
                        const row = Math.floor(index / COLS);
                        ctx.drawImage(texture.image, col * PHOTO_SIZE, row * PHOTO_SIZE, PHOTO_SIZE, PHOTO_SIZE);
                    });
                    photoAtlas.needsUpdate = true;
                    // æ›´æ–°ç…§ç‰‡ Mesh çš„çº¹ç†
                    if (elementsMesh) {
                        elementsMesh.material.uniforms.u_photoTexture.value = photoAtlas;
                    }
                }
            };

            textures.forEach(texture => {
                if (texture.image && texture.image.complete) {
                    onPhotoLoad();
                } else if (texture.image) {
                    texture.image.onload = onPhotoLoad;
                } else {
                    // é»˜è®¤çº¹ç†å·²åŠ è½½
                    onPhotoLoad();
                }
            });

            return photoAtlas;
        }

        /**
         * åˆ›å»º Instanced Mesh
         */
        function createElements() {
            // å‡ ä½•ä½“ï¼šä½¿ç”¨ä¸€ä¸ªåŒ…å«æ‰€æœ‰å…ƒç´ å‡ ä½•ä½“çš„ BufferGeometry
            const geometries = [
                new THREE.SphereGeometry(0.5, 8, 8),    // 0: Sphere (çƒ)
                new THREE.BoxGeometry(0.5, 0.5, 0.5),   // 1: Cube (æ­£æ–¹ä½“)
                new THREE.CylinderGeometry(0.2, 0.2, 1.0, 8), // 2: Candy (ç³–æœæ£)
                new THREE.PlaneGeometry(3, 2)           // 3: Photo (ç…§ç‰‡å¹³é¢)
            ];

            const combinedGeometry = new THREE.BufferGeometry();
            const positionsArray = [];
            const normalsArray = [];
            const uvsArray = [];
            const indicesArray = [];
            let offset = 0;

            geometries.forEach((geometry, type) => {
                const pos = geometry.attributes.position.array;
                const norm = geometry.attributes.normal.array;
                const uv = geometry.attributes.uv.array;
                const ind = geometry.index.array;

                positionsArray.push(...pos);
                normalsArray.push(...norm);
                uvsArray.push(...uv);

                for (let i = 0; i < ind.length; i++) {
                    indicesArray.push(ind[i] + offset);
                }
                offset += pos.length / 3;
            });

            combinedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positionsArray, 3));
            combinedGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normalsArray, 3));
            combinedGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvsArray, 2));
            combinedGeometry.setIndex(indicesArray);

            // æè´¨
            const material = createInstancedMaterial();
            const photoMaterial = createInstancedMaterial(true); // ç…§ç‰‡ä¸“ç”¨æè´¨

            // Instanced Mesh
            elementsMesh = new THREE.InstancedMesh(combinedGeometry, material, NUM_ELEMENTS);
            elementsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(elementsMesh);

            // ç…§ç‰‡ Instanced Mesh (ä½¿ç”¨ PlaneGeometry)
            const photoGeometry = new THREE.PlaneGeometry(3, 2);
            photoMesh = new THREE.InstancedMesh(photoGeometry, photoMaterial, NUM_PHOTOS);
            photoMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
            scene.add(photoMesh);

            // å‡†å¤‡å®ä¾‹å±æ€§
            const instancePosition = new Float32Array(NUM_ELEMENTS * 3);
            const instanceRotation = new Float32Array(NUM_ELEMENTS * 4);
            const instanceColor = new Float32Array(NUM_ELEMENTS * 3);
            const instanceType = new Float32Array(NUM_ELEMENTS);
            const instanceTextureIndex = new Float32Array(NUM_ELEMENTS);

            // å¡«å……æ•°æ®
            const tempPosition = new THREE.Vector3();
            const tempQuaternion = new THREE.Quaternion();
            const color = new THREE.Color();

            for (let i = 0; i < NUM_ELEMENTS; i++) {
                // æ•£å¼€æ€ç›®æ ‡ä½ç½® (éšæœºåˆ†å¸ƒåœ¨ä¸€ä¸ªçƒä½“å†…)
                const radius = 20 + Math.random() * 10;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                tempPosition.setFromSphericalCoords(radius, phi, theta);
                positions.push(tempPosition.x, tempPosition.y, tempPosition.z);
                currentPositions.push(0, i * 0.2 + 0.1, 0); // åˆå§‹ä½ç½®æ¥è¿‘åˆæ‹¢æ€

                // éšæœºæ—‹è½¬
                tempQuaternion.setFromEuler(new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI));
                rotations.push(tempQuaternion.x, tempQuaternion.y, tempQuaternion.z, tempQuaternion.w);

                // å…ƒç´ ç±»å‹å’Œé¢œè‰²
                let type;
                if (i < NUM_PHOTOS) {
                    // å‰ NUM_PHOTOS ä¸ªæ˜¯ç…§ç‰‡
                    type = ELEMENT_TYPES.PHOTO;
                    color.set(COLORS.WHITE);
                    instanceTextureIndex[i] = i; // ç…§ç‰‡ç´¢å¼•
                } else {
                    // å…¶ä»–æ˜¯è£…é¥°ç‰©
                    type = Math.floor(Math.random() * 3); // 0, 1, 2 (Sphere, Cube, Candy)
                    const randomVal = Math.random();
                    if (type === ELEMENT_TYPES.CUBE) {
                        color.set(COLORS.GREEN).lerp(COLORS.WHITE, randomVal * 0.1);
                    } else if (type === ELEMENT_TYPES.SPHERE) {
                        color.set(COLORS.GOLD).lerp(COLORS.WHITE, randomVal * 0.2);
                    } else {
                        color.set(COLORS.RED).lerp(COLORS.WHITE, randomVal * 0.1);
                    }
                }
                instanceColor.set(color.toArray(), i * 3);
                instanceType[i] = type;
            }

            // æ·»åŠ  Instanced Attributes
            elementsMesh.geometry.setAttribute('instancePosition', new THREE.InstancedBufferAttribute(new Float32Array(positions), 3));
            elementsMesh.geometry.setAttribute('instanceRotation', new THREE.InstancedBufferAttribute(new Float32Array(rotations), 4));
            elementsMesh.geometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(instanceColor, 3));
            elementsMesh.geometry.setAttribute('instanceType', new THREE.InstancedBufferAttribute(instanceType, 1));
            elementsMesh.geometry.setAttribute('instanceTextureIndex', new THREE.InstancedBufferAttribute(instanceTextureIndex, 1));

            // æ›´æ–°ç…§ç‰‡ Mesh çš„å±æ€§ (åªéœ€è¦å‰ NUM_PHOTOS ä¸ªå®ä¾‹)
            photoMesh.geometry.setAttribute('instancePosition', new THREE.InstancedBufferAttribute(new Float32Array(positions.slice(0, NUM_PHOTOS * 3)), 3));
            photoMesh.geometry.setAttribute('instanceRotation', new THREE.InstancedBufferAttribute(new Float32Array(rotations.slice(0, NUM_PHOTOS * 4)), 4));
            photoMesh.geometry.setAttribute('instanceColor', new THREE.InstancedBufferAttribute(instanceColor.slice(0, NUM_PHOTOS * 3), 3));
            photoMesh.geometry.setAttribute('instanceType', new THREE.InstancedBufferAttribute(instanceType.slice(0, NUM_PHOTOS), 1));
            photoMesh.geometry.setAttribute('instanceTextureIndex', new THREE.InstancedBufferAttribute(instanceTextureIndex.slice(0, NUM_PHOTOS), 1));

            // åŠ è½½é»˜è®¤ç…§ç‰‡çº¹ç†
            const defaultUrls = Array(NUM_PHOTOS).fill('https://picsum.photos/256/256');
            loadPhotoTextures(defaultUrls);
        }

        /**
         * å¯åŠ¨ MediaPipe Hands
         */
        function initMediaPipe() {
            videoElement = document.getElementById('video-feedback');
            const handStateEl = document.getElementById('hand-state');

            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.6
            });

            hands.onResults((results) => {
                lastHandLandmarks = results.landmarks[0] || null;
                updateHandGesture(lastHandLandmarks);
                handStateEl.textContent = getGestureName();
            });

            const cameraMedia = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 640,
                height: 480
            });
            cameraMedia.start();
        }

        // --- 4. äº¤äº’é€»è¾‘ ---

        /**
         * æ£€æµ‹å½“å‰æ‰‹åŠ¿å¹¶æ›´æ–°çŠ¶æ€
         * @param {number[][]} landmarks - 21ä¸ªæ‰‹éƒ¨å…³é”®ç‚¹
         */
        function updateHandGesture(landmarks) {
            if (!landmarks) {
                handClosed = false;
                handOpen = false;
                handPinching = false;
                handRotating = false;
                return;
            }

            // 1. æ¡æ‹³ (Fist): é£ŸæŒ‡å°– (8) å’Œæ‹‡æŒ‡å°– (4) çš„è·ç¦»éå¸¸å°
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const thumbIndexDist = Math.hypot(thumbTip[0] - indexTip[0], thumbTip[1] - indexTip[1]);

            // 2. äº”æŒ‡å¼ å¼€ (Open Palm): æ‰€æœ‰æŒ‡å°–(4, 8, 12, 16, 20) ç¦»æ‰‹æŒä¸­å¿ƒ(0) çš„è·ç¦»éƒ½æ¯”è¾ƒå¤§
            const palmBase = landmarks[0];
            const tips = [landmarks[4], landmarks[8], landmarks[12], landmarks[16], landmarks[20]];
            const avgTipDist = tips.reduce((sum, tip) => sum + Math.hypot(tip[0] - palmBase[0], tip[1] - palmBase[1]), 0) / 5;

            // 3. æŠ“å– (Pinch/Grab): æ‹‡æŒ‡å°– (4) å’Œé£ŸæŒ‡å°– (8) ä¹‹é—´çš„è·ç¦»å°ï¼Œä¸”å…¶ä»–æ‰‹æŒ‡å¼¯æ›²
            const pinchThreshold = 0.05; // å½’ä¸€åŒ–åæ ‡è·ç¦»
            const openThreshold = 0.2; // å½’ä¸€åŒ–åæ ‡è·ç¦»
            const grabThreshold = 0.15; // å¹³å‡è·ç¦»é˜ˆå€¼

            handClosed = thumbIndexDist < pinchThreshold;
            handOpen = avgTipDist > openThreshold && thumbIndexDist > pinchThreshold * 2;
            handPinching = thumbIndexDist < pinchThreshold && avgTipDist < grabThreshold;

            // çŠ¶æ€æœºåˆ‡æ¢
            if (handClosed && targetState !== STATE.CONE) {
                setTargetState(STATE.CONE);
                document.getElementById('scene-state').textContent = 'åˆæ‹¢æ€ (Fist)';
                focusedPhotoIndex = -1; // å–æ¶ˆèšç„¦
            } else if (handOpen && targetState !== STATE.SCATTER && targetState !== STATE.FOCUS) {
                setTargetState(STATE.SCATTER);
                document.getElementById('scene-state').textContent = 'æ•£å¼€æ€ (Open)';
                focusedPhotoIndex = -1;
            }

            // 4. æ‰‹æ—‹è½¬/ç§»åŠ¨ (ç”¨äºç›¸æœºæ§åˆ¶)
            if (targetState === STATE.SCATTER) {
                if (lastHandX !== 0) {
                    // è®¡ç®—æ‰‹éƒ¨ç§»åŠ¨é‡ (å½’ä¸€åŒ–åæ ‡)
                    const deltaX = (landmarks[0][0] - lastHandX) * 100; // æ”¾å¤§ç³»æ•°
                    const deltaY = (landmarks[0][1] - lastHandY) * 100;
                    
                    // å¹³æ»‘è°ƒæ•´ç›¸æœºæ—‹è½¬é€Ÿåº¦
                    cameraRotationVelocity.x += deltaX * 0.005;
                    cameraRotationVelocity.y += deltaY * 0.005;
                    handRotating = Math.abs(deltaX) > 0.5 || Math.abs(deltaY) > 0.5;
                }
                lastHandX = landmarks[0][0];
                lastHandY = landmarks[0][1];
            } else {
                lastHandX = 0;
                lastHandY = 0;
                cameraRotationVelocity.set(0, 0); // éæ•£å¼€æ€ä¸æ—‹è½¬
            }

            // 5. æŠ“å– (Pinch/Grab) -> ç…§ç‰‡æ”¾å¤§æ€
            if (handPinching && targetState === STATE.SCATTER && transitionTime === 0) {
                // ä»…åœ¨æ•£å¼€æ€ä¸”ç¨³å®šæ—¶è§¦å‘
                const grabX = landmarks[8][0] * window.innerWidth; // é£ŸæŒ‡ X å±å¹•åæ ‡
                const grabY = landmarks[8][1] * window.innerHeight; // é£ŸæŒ‡ Y å±å¹•åæ ‡

                // è¿›è¡Œå°„çº¿æ£€æµ‹ï¼Œæ‰¾åˆ°è¢«â€œæŠ“â€åˆ°çš„ç…§ç‰‡
                const index = raycastForPhoto(grabX, grabY);
                if (index !== -1) {
                    focusedPhotoIndex = index;
                    setTargetState(STATE.FOCUS);
                    document.getElementById('scene-state').textContent = `ç…§ç‰‡æ”¾å¤§æ€ (Focus #${index})`;
                }
            } else if (!handPinching && targetState === STATE.FOCUS) {
                // é‡Šæ”¾æŠ“å–ï¼Œå›åˆ°æ•£å¼€æ€
                setTargetState(STATE.SCATTER);
                document.getElementById('scene-state').textContent = 'æ•£å¼€æ€ (Open)';
            }
        }

        /**
         * è·å–å½“å‰æ‰‹åŠ¿åç§° (ç”¨äº UI)
         */
        function getGestureName() {
            if (targetState === STATE.FOCUS) return `æŠ“å–ä¸­ (Focus #${focusedPhotoIndex})`;
            if (handClosed) return 'æ¡æ‹³ (Fist)';
            if (handOpen) return 'äº”æŒ‡å¼ å¼€ (Open Palm)';
            if (handPinching) return 'æŠ“å–é¢„å¤‡ (Pinch)';
            if (handRotating) return 'ç”»é¢æ—‹è½¬ä¸­ (Rotate)';
            return 'æœªæ£€æµ‹åˆ°æ‰‹åŠ¿';
        }

        /**
         * è®¾ç½®ç›®æ ‡çŠ¶æ€å¹¶å¯åŠ¨è¿‡æ¸¡åŠ¨ç”»
         * @param {string} newState - ç›®æ ‡çŠ¶æ€ (CONE, SCATTER, FOCUS)
         */
        function setTargetState(newState) {
            if (targetState === newState) return;

            targetState = newState;
            transitionTime = 0.000001; // é¿å…ä¸º 0 å¯¼è‡´ç«‹å³ç»“æŸ
        }

        /**
         * å°„çº¿æ£€æµ‹ï¼ŒæŸ¥æ‰¾è¢«æŠ“å–çš„ç…§ç‰‡
         * @param {number} x - å±å¹• X åæ ‡
         * @param {number} y - å±å¹• Y åæ ‡
         * @returns {number} - ç…§ç‰‡å®ä¾‹ç´¢å¼•ï¼Œæœªæ‰¾åˆ°è¿”å› -1
         */
        function raycastForPhoto(x, y) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            // å°†å±å¹•åæ ‡è½¬æ¢ä¸ºå½’ä¸€åŒ–è®¾å¤‡åæ ‡ (NDC)
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = - (y / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // ä»…å¯¹ç…§ç‰‡å®ä¾‹è¿›è¡Œæ£€æµ‹
            const intersects = raycaster.intersectObject(photoMesh);

            if (intersects.length > 0) {
                // InstancedMesh çš„ intersection åŒ…å« instanceId
                return intersects[0].instanceId;
            }
            return -1;
        }

        // --- 5. åŠ¨ç”»å¾ªç¯ ---

        const clock = new THREE.Clock();
        const TRANSITION_DURATION = 1.0; // è¿‡æ¸¡åŠ¨ç”»æŒç»­æ—¶é—´ (ç§’)

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();

            // 1. çŠ¶æ€è¿‡æ¸¡æ›´æ–°
            if (transitionTime > 0) {
                transitionTime += delta;
                if (transitionTime >= TRANSITION_DURATION) {
                    transitionTime = 0;
                    state = targetState; // è¿‡æ¸¡ç»“æŸï¼Œæ›´æ–°å½“å‰çŠ¶æ€
                }
            } else if (state !== targetState) {
                 // ç«‹å³å¼€å§‹è¿‡æ¸¡ (è§£å†³æ‰‹åŠ¿å¿«é€Ÿå˜åŒ–çš„é—®é¢˜)
                 transitionTime = 0.000001;
            }

            // æ›´æ–° Uniforms
            if (elementsMesh && photoMesh) {
                const material = elementsMesh.material;
                const photoMaterial = photoMesh.material;

                material.uniforms.u_time.value = elapsed;
                material.uniforms.u_transitionTime.value = transitionTime;
                material.uniforms.u_maxTransitionTime.value = TRANSITION_DURATION;
                material.uniforms.u_focusIndex.value = focusedPhotoIndex;

                photoMaterial.uniforms.u_time.value = elapsed;
                photoMaterial.uniforms.u_transitionTime.value = transitionTime;
                photoMaterial.uniforms.u_maxTransitionTime.value = TRANSITION_DURATION;
                photoMaterial.uniforms.u_focusIndex.value = focusedPhotoIndex;
            }

            // 2. ç›¸æœº/åœºæ™¯æ—‹è½¬ (ä»…åœ¨ SCATTER æˆ– FOCUS çŠ¶æ€ä¸‹)
            if (state === STATE.SCATTER || state === STATE.FOCUS) {
                // åº”ç”¨é˜»å°¼
                cameraRotationVelocity.multiplyScalar(cameraRotationDamping);

                // æ›´æ–°æ—‹è½¬
                cameraTarget.x += cameraRotationVelocity.x;
                cameraTarget.y += cameraRotationVelocity.y;

                // é™åˆ¶æ—‹è½¬èŒƒå›´ (å¯é€‰)
                cameraTarget.x = Math.max(-10, Math.min(10, cameraTarget.x));
                cameraTarget.y = Math.max(-10, Math.min(10, cameraTarget.y));

                // å›´ç»•ä¸­å¿ƒç‚¹æ—‹è½¬ç›¸æœº
                const radius = camera.position.length();
                const theta = Math.atan2(camera.position.z, camera.position.x) + cameraRotationVelocity.x * delta * 0.5;
                const phi = Math.acos(camera.position.y / radius) + cameraRotationVelocity.y * delta * 0.5;

                // æ›´æ–°ç›¸æœºä½ç½® (çƒé¢åæ ‡)
                camera.position.x = radius * Math.sin(phi) * Math.cos(theta);
                camera.position.y = radius * Math.cos(phi);
                camera.position.z = radius * Math.sin(phi) * Math.sin(theta);

                camera.lookAt(0, 5, 0); // å§‹ç»ˆçœ‹å‘åœ£è¯æ ‘ä¸­å¿ƒ
            }

            // 3. æ›´æ–° Instanced Mesh çŸ©é˜µ (å°†å½“å‰ä½ç½®å†™å…¥å®ä¾‹çŸ©é˜µ)
            if (elementsMesh && photoMesh) {
                updateInstancedMatrices();
            }

            // 4. æ¸²æŸ“
            composer.render();
        }

        /**
         * æ›´æ–°æ‰€æœ‰å®ä¾‹çš„å½“å‰å˜æ¢çŸ©é˜µ
         */
        const dummy = new THREE.Object3D();
        const tempPosition = new THREE.Vector3();
        const tempRotation = new THREE.Quaternion();
        const tempScale = new THREE.Vector3(1, 1, 1);
        const conePos = new THREE.Vector3();
        const scatterPos = new THREE.Vector3();
        const focusPos = new THREE.Vector3(0, 5, 10); // èšç„¦ä½ç½®

        function updateInstancedMatrices() {
            const positionsAttribute = elementsMesh.geometry.attributes.instancePosition;
            const rotationsAttribute = elementsMesh.geometry.attributes.instanceRotation;
            const currentTransition = transitionTime > 0 ? transitionTime / TRANSITION_DURATION : 0;

            for (let i = 0; i < NUM_ELEMENTS; i++) {
                // è¯»å–éšæœºæ•£å¼€ä½ç½®
                scatterPos.fromArray(positionsAttribute.array, i * 3);
                // è¯»å–éšæœºæ—‹è½¬
                tempRotation.fromArray(rotationsAttribute.array, i * 4);

                // 1. è®¡ç®—ç›®æ ‡ä½ç½®
                let targetPos = new THREE.Vector3();
                let isPhoto = elementsMesh.geometry.attributes.instanceType.array[i] === ELEMENT_TYPES.PHOTO;

                // åˆæ‹¢æ€ç›®æ ‡
                const r = Math.sqrt(i) * 0.2;
                const a = i * 0.25;
                const y = i * 0.2 + 0.1;
                conePos.set(r * Math.cos(a), y, r * Math.sin(a));

                if (i === focusedPhotoIndex && (targetState === STATE.FOCUS || state === STATE.FOCUS) && isPhoto) {
                     // ç…§ç‰‡æ”¾å¤§æ€ï¼šç›®æ ‡ä½ç½®åœ¨ç›¸æœºå‰æ–¹
                     targetPos.copy(focusPos);
                } else if (targetState === STATE.CONE) {
                    targetPos.copy(conePos);
                } else { // SCATTER
                    targetPos.copy(scatterPos);
                }

                // 2. è®¡ç®—å½“å‰ä½ç½® (ä¸ºäº†å¹³æ»‘è¿‡æ¸¡ï¼Œéœ€è¦æ’å€¼)
                if (currentTransition > 0) {
                     // ç®€å•å¤„ç†ï¼šæ’å€¼è®¡ç®—ç›®æ ‡ä½ç½® (å› ä¸ºé¡¶ç‚¹ç€è‰²å™¨ä¸­ä¹Ÿè¿›è¡Œäº†æ’å€¼ï¼Œè¿™é‡Œåªéœ€ç¡®ä¿çŸ©é˜µæ›´æ–°)
                     // é¡¶ç‚¹ç€è‰²å™¨è´Ÿè´£å¹³æ»‘è¿‡æ¸¡ï¼Œè¿™é‡Œæˆ‘ä»¬åªéœ€å°†æ’å€¼åçš„ä½ç½®å†™å…¥å½“å‰çŸ©é˜µï¼Œä»¥ä¾¿ Raycaster å’Œç›¸æœºæ—‹è½¬æ—¶èƒ½æ­£ç¡®çœ‹å‘/æ£€æµ‹åˆ°å®ƒä»¬
                     tempPosition.copy(conePos); // å‡è®¾ä»åˆæ‹¢æ€å¼€å§‹
                     tempPosition.lerp(targetPos, currentTransition);
                } else {
                     tempPosition.copy(targetPos);
                }

                // 3. åº”ç”¨å˜æ¢
                dummy.position.copy(tempPosition);
                dummy.rotation.setFromQuaternion(tempRotation);
                dummy.scale.setScalar(isPhoto ? 1.0 : 0.5); // ç…§ç‰‡å°ºå¯¸å¤§ä¸€äº›

                // 4. æ›´æ–° Instanced Mesh çŸ©é˜µ
                dummy.updateMatrix();

                // å°†çŸ©é˜µå†™å…¥ç›¸åº”çš„ Mesh
                if (isPhoto && i < NUM_PHOTOS) {
                    // ç…§ç‰‡å®ä¾‹
                    photoMesh.setMatrixAt(i, dummy.matrix);
                } else if (!isPhoto) {
                    // éç…§ç‰‡å®ä¾‹
                    elementsMesh.setMatrixAt(i, dummy.matrix);
                }
            }

            elementsMesh.instanceMatrix.needsUpdate = true;
            photoMesh.instanceMatrix.needsUpdate = true;
        }


        // --- 6. äº‹ä»¶å¤„ç† ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        document.getElementById('photo-upload').addEventListener('change', (event) => {
            const files = event.target.files;
            const newUrls = [];
            for (let i = 0; i < Math.min(files.length, NUM_PHOTOS); i++) {
                newUrls.push(URL.createObjectURL(files[i]));
            }

            // é‡æ–°åŠ è½½çº¹ç†å›¾é›†
            const newAtlas = loadPhotoTextures(newUrls);
            elementsMesh.material.uniforms.u_photoTexture.value = newAtlas;
            photoMesh.material.uniforms.u_photoTexture.value = newAtlas;
        });

        // --- 7. ä¸»å‡½æ•° ---

        function main() {
            initThree();
            createElements();
            initMediaPipe();
            animate();
        }

        // é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨åº”ç”¨
        window.onload = main;
    </script>
</body>
</html>
