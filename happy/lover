<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ„ 3D è–èª•ç…§ç‰‡ç‰† (MediaPipe äº’å‹•)</title>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/vision_bundle.js"
            }
        }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { position: absolute; width: 100%; height: 100%; }
        
        /* --- UI å…ƒç´  --- */
        #ui-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .action-button {
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.85);
            border: 2px solid #333;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            transition: background-color 0.2s;
        }

        .action-button:hover {
            background-color: #e0e0e0;
        }

        /* --- è¼‰å…¥å’ŒéŒ¯èª¤æç¤º --- */
        #loader, #error-message {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            flex-direction: column;
            text-align: center;
            z-index: 1000;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #e74c3c;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <button class="action-button">æ·»åŠ ç…§ç‰‡</button>
        <button class="action-button">ç®¡ç†ç…§ç‰‡</button>
        <button class="action-button">æ·»åŠ éŸ³æ¨‚</button>
    </div>

    <div id="loader">
        <div class="spinner"></div>
        è¼‰å…¥ 3D è³‡æºèˆ‡ MediaPipe æ¨¡å‹ä¸­...
    </div>

    <div id="error-message" class="hidden">
        âš ï¸ éŒ¯èª¤ï¼šç„¡æ³•åˆå§‹åŒ–ã€‚è«‹æª¢æŸ¥ï¼š
        <ol style="text-align: left; margin-top: 10px;">
            <li>ç€è¦½å™¨æ˜¯å¦å…è¨±æ”åƒé ­æ¬Šé™ã€‚</li>
            <li>æ‚¨æ˜¯å¦ä½¿ç”¨ HTTPS æˆ–æœ¬åœ°æ–‡ä»¶ç³»çµ± (é›™æ“Š HTML) é‹è¡Œã€‚</li>
        </ol>
    </div>

    <video id="webcam-video" style="display:none;" autoplay playsinline></video>

    <script type="module">
        import * as THREE from 'three';
        import { HandLandmarker, FilesetResolver } from '@mediapipe/tasks-vision';
        
        // --- å…¨å±€ç‹€æ…‹å’Œé…ç½® ---
        let scene, camera, renderer;
        let video, handLandmarker;
        let photoParticles = [];
        let currentState = 'SCATTER'; // åˆå§‹ç‹€æ…‹
        let handNormalizedX = 0.5, handNormalizedY = 0.5; // ç”¨æ–¼æ—‹è½‰
        
        const ROTATION_FACTOR = 1.2; // æ—‹è½‰é€Ÿåº¦ä¿‚æ•¸

        // å‡å®šç…§ç‰‡æ•¸æ“š (å¯¦éš›æ‡‰ç”¨ä¸­éœ€è¦å‹•æ…‹åŠ è¼‰)
        const dummyPhotos = [
            'https://picsum.photos/id/237/200/200',
            'https://picsum.photos/id/1080/200/200',
            'https://picsum.photos/id/200/200/200',
            // æ³¨æ„: ç‚ºäº†æœ¬åœ°é›™æ“Šé‹è¡Œï¼Œæ‚¨å¯èƒ½éœ€è¦å°‡é€™äº› URL æ›¿æ›ç‚º Base64 æ•¸æ“šæˆ–æœ¬åœ°è·¯å¾‘ (éœ€ç¢ºä¿ Three.js çš„è·¨åŸŸè¨­ç½®å…è¨±)
        ];

        // --- è¼”åŠ©å‡½æ•¸ ---

        function showLoader(visible = true) {
            document.getElementById('loader').classList.toggle('hidden', !visible);
        }

        function showError(message) {
            document.getElementById('loader').classList.add('hidden');
            const errorDiv = document.getElementById('error-message');
            errorDiv.innerHTML = `âš ï¸ éŒ¯èª¤: ${message}`;
            errorDiv.classList.remove('hidden');
        }

        // --- Three.js åˆå§‹åŒ– ---

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- ç²’å­ç³»çµ± (ç…§ç‰‡) å‰µå»ºèˆ‡ç®¡ç† ---

        function loadPhotosAndCreateParticles() {
            const manager = new THREE.LoadingManager();
            const textureLoader = new THREE.TextureLoader(manager);

            manager.onLoad = () => {
                showLoader(false); // æ‰€æœ‰ç´‹ç†åŠ è¼‰å®Œæˆ
            };

            dummyPhotos.forEach((url, index) => {
                textureLoader.load(url, (texture) => {
                    // å‰µå»ºç…§ç‰‡é¢ç‰‡
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                    const photoMesh = new THREE.Mesh(geometry, material);
                    
                    // åˆå§‹åŒ–ä½ç½®å’Œç›®æ¨™ä½ç½®
                    photoMesh.position.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10
                    );

                    // å„²å­˜ç‹€æ…‹å’Œç›®æ¨™
                    photoMesh.userData = {
                        scatterPos: photoMesh.position.clone(),
                        treePos: calculateTreePosition(index), // éœ€è¦å¯¦ç¾
                        initialScale: photoMesh.scale.clone(),
                        targetPos: photoMesh.position.clone(),
                        targetScale: photoMesh.scale.clone(),
                        isFocused: false
                    };
                    
                    scene.add(photoMesh);
                    photoParticles.push(photoMesh);

                    // åˆå§‹è¨­å®šç‚ºæ•£é–‹æ…‹ç›®æ¨™
                    updateParticlesTargetToRandom(); 
                }, undefined, (error) => {
                    console.error('ç´‹ç†åŠ è¼‰å¤±æ•—:', url, error);
                    // å³ä½¿å¤±æ•—ä¹Ÿç¹¼çºŒï¼Œä½†ä¸å½±éŸ¿æ•´é«”é‚è¼¯
                });
            });
        }
        
        /**
         * å¯¦ç¾: è¨ˆç®—ç²’å­åœ¨è–èª•æ¨¹å½¢ç‹€ä¸Šçš„ç›®æ¨™ä½ç½® (èºæ—‹åœ“éŒé«”)
         * @param {number} index - ç²’å­ç´¢å¼•
         * @returns {THREE.Vector3} è–èª•æ¨¹ä¸Šçš„åº§æ¨™
         */
        function calculateTreePosition(index) {
            const count = dummyPhotos.length;
            const height = 8;
            const radius = 3;
            const angle = index / count * Math.PI * 8; // 8åœˆèºæ—‹
            const y = (index / count) * height - (height / 2); // å¾åº•åˆ°é ‚
            const r = radius * (1 - index / count); // åŠå¾‘å¾å¤§è®Šå°
            
            return new THREE.Vector3(
                Math.cos(angle) * r,
                y,
                Math.sin(angle) * r
            );
        }
        
        // --- ç‹€æ…‹ç›®æ¨™åˆ‡æ›é‚è¼¯ ---

        function updateParticlesTargetToTree() {
            photoParticles.forEach(p => {
                p.userData.targetPos.copy(p.userData.treePos);
                p.userData.targetScale.copy(p.userData.initialScale);
            });
        }

        function updateParticlesTargetToRandom() {
            photoParticles.forEach(p => {
                // ç”±æ–¼ scatterPos åœ¨å‰µå»ºæ™‚å°±æ˜¯éš¨æ©Ÿçš„ï¼Œé€™è£¡ç›´æ¥ä½¿ç”¨
                p.userData.targetPos.copy(p.userData.scatterPos);
                p.userData.targetScale.copy(p.userData.initialScale);
            });
        }

        // --- MediaPipe åˆå§‹åŒ–èˆ‡é‹è¡Œ ---

        async function initMediaPipe() {
            const filesetResolver = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm"
            );
            
            handLandmarker = await HandLandmarker.create(filesetResolver, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU" // å˜—è©¦ä½¿ç”¨ GPU åŠ é€Ÿ
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            
            // ç²å–æ”åƒé ­è¦–é »æµ
            video = document.getElementById('webcam-video');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            
            return new Promise((resolve) => {
                video.onloadeddata = () => {
                    video.play();
                    resolve();
                };
            });
        }

        // --- MediaPipe æª¢æ¸¬èˆ‡æ‰‹å‹¢åˆ¤æ–· ---

        function detectHand() {
            if (handLandmarker && video.readyState === 4) {
                 // åœ¨è¦–é »å¹€ä¸Šé‹è¡Œå¯¦æ™‚æª¢æ¸¬
                handLandmarker.detectForVideo(video, performance.now(), onHandResults);
            }
        }

        /**
         * æª¢æŸ¥æŒ‡å°–èˆ‡æŒå¿ƒçš„è·é›¢ä¾†åˆ¤æ–·æ‰‹å‹¢ã€‚
         * @param {Array<THREE.Vector3>} landmarks - æ­¸ä¸€åŒ–åº§æ¨™é» (0åˆ°1)
         */
        function determineHandGesture(landmarks) {
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];

            // æåˆ (FOCUS): æ‹‡æŒ‡å°–å’Œé£ŸæŒ‡å°–è·é›¢éå¸¸è¿‘
            const pinchDistance = thumbTip.distanceTo(indexTip);
            if (pinchDistance < 0.04) { // å‡è¨­ä¸€å€‹å°çš„é–¾å€¼
                return 'FOCUS';
            }
            
            // æ¡æ‹³ (TREE): æ‰€æœ‰æŒ‡å°–é›¢è…•éƒ¨è·é›¢éƒ½å¾ˆå°
            const fingerTips = [indexTip, middleTip, ringTip, pinkyTip];
            const maxFingerWristDistance = Math.max(...fingerTips.map(tip => tip.distanceTo(wrist)));
            
            if (maxFingerWristDistance < 0.15) { // å‡è¨­ä¸€å€‹è¼ƒå°çš„é–¾å€¼
                return 'TREE';
            }

            // å¼µé–‹ (SCATTER): é»˜èªæˆ–ä¸ç¬¦åˆå‰å…©è€…çš„æƒ…æ³
            return 'SCATTER';
        }
        
        function onHandResults(result) {
            if (result.landmarks && result.landmarks.length > 0) {
                const landmarks = result.landmarks[0];
                
                // è¨ˆç®—æ‰‹éƒ¨ä¸­å¿ƒé»çš„æ­¸ä¸€åŒ–åº§æ¨™ (ä¾‹å¦‚ä½¿ç”¨ Wrist, é» 0)
                handNormalizedX = landmarks[0].x;
                handNormalizedY = landmarks[0].y;
                
                const newState = determineHandGesture(landmarks);
                
                if (newState !== currentState) {
                    currentState = newState;
                    
                    // åŸ·è¡Œç‹€æ…‹åˆ‡æ›å‹•ä½œ
                    if (currentState === 'TREE') {
                        updateParticlesTargetToTree();
                    } else if (currentState === 'SCATTER') {
                        // å¦‚æœå¾ FOCUS åˆ‡æ›å›ä¾†ï¼Œéœ€è¦é‡ç½®è¢«æŠ“å–çš„ç…§ç‰‡
                        resetFocusedPhoto(); 
                        updateParticlesTargetToRandom();
                    }
                }
                
                // è™•ç†æŒçºŒæ€§ç‹€æ…‹äº¤äº’
                if (currentState === 'SCATTER') {
                    applyEdgeRotation();
                } else if (currentState === 'FOCUS') {
                    focusOnNearestPhoto();
                }
                
            } else {
                // å¦‚æœæ‰‹å‹¢æ¶ˆå¤±ï¼Œä¸”ç›®å‰æ˜¯ FOCUS ç‹€æ…‹ï¼Œå‰‡é‡‹æ”¾ç…§ç‰‡
                if (currentState === 'FOCUS') {
                     resetFocusedPhoto();
                     currentState = 'SCATTER'; // æ¢å¾©åˆ°æ•£é–‹ç‹€æ…‹
                }
                // æ‰‹éƒ¨ä¸åœ¨è¢å¹•ä¸Šæ™‚ï¼Œåœæ­¢æ—‹è½‰
                scene.rotation.y *= 0.98; // ç·©æ…¢åœæ­¢
            }
        }

        // --- äº¤äº’å¯¦ç¾ ---

        function applyEdgeRotation() {
            // è¨ˆç®—æ‰‹éƒ¨ä¸­å¿ƒåˆ°å±å¹•ä¸­å¿ƒçš„è·é›¢ (æ­¸ä¸€åŒ–åº§æ¨™ 0åˆ°1)
            const dx = handNormalizedX - 0.5;
            const dy = handNormalizedY - 0.5;
            
            // æ­å¹¾é‡Œå¾—è·é›¢
            const distance = Math.sqrt(dx * dx + dy * dy); 
            
            // æ—‹è½‰é€Ÿåº¦ï¼šè·é›¢è¶Šé ï¼Œé€Ÿåº¦è¶Šå¿«ï¼Œæœ€å¤§ç‚º ROTATION_FACTOR
            const rotationSpeed = distance * ROTATION_FACTOR * 0.05; 
            
            // æ‡‰ç”¨æ—‹è½‰ (ä»¥ Y è»¸ç‚ºä¸»)
            // æ ¹æ“š X è»¸æ–¹å‘æ±ºå®šæ—‹è½‰æ–¹å‘ (å·¦é‚Šæ˜¯è² ï¼Œå³é‚Šæ˜¯æ­£)
            scene.rotation.y += rotationSpeed * (dx > 0 ? 1 : -1); 
        }

        let focusedPhoto = null;
        
        function focusOnNearestPhoto() {
            if (focusedPhoto) {
                // å¦‚æœå·²ç¶“é–å®šï¼Œå‰‡ä¿æŒé–å®š
                return; 
            }
            
            const centerVector = new THREE.Vector3(0, 0, 0); // å±å¹•ä¸­å¿ƒ (NDC åº§æ¨™)
            let nearestDistance = Infinity;
            let candidatePhoto = null;
            const FOCUS_RADIUS = 0.55; // åˆ¤å®šåŠå¾‘æ“´å¤§è‡³ 0.55

            photoParticles.forEach(p => {
                // 1. å°‡ 3D åº§æ¨™æŠ•å½±åˆ° 2D å±å¹•åº§æ¨™ (NDC)
                const vector = p.position.clone();
                vector.project(camera); 
                
                // 2. è¨ˆç®—åˆ°å±å¹•ä¸­å¿ƒçš„ 2D è·é›¢
                // vector.x å’Œ vector.y ç¯„åœæ˜¯ [-1, 1]
                const distToCenter = vector.distanceTo(centerVector); 

                // 3. åˆ¤æ–·æ˜¯å¦åœ¨åˆ¤å®šåŠå¾‘å…§
                if (distToCenter < FOCUS_RADIUS) {
                    // 4. æ‰¾åˆ°è·é›¢æœ€è¿‘çš„ä¸€å¼µ
                    if (distToCenter < nearestDistance) {
                        nearestDistance = distToCenter;
                        candidatePhoto = p;
                    }
                }
            });

            if (candidatePhoto) {
                focusedPhoto = candidatePhoto;
                focusedPhoto.userData.isFocused = true;
                
                // ç›®æ¨™ä½ç½®: é¡é ­å‰æ–¹
                const focusTargetPos = new THREE.Vector3(0, 0, -2); // ç›¸æ©Ÿå±€éƒ¨åº§æ¨™
                focusTargetPos.applyMatrix4(camera.matrixWorld); // è½‰æ›åˆ°ä¸–ç•Œåº§æ¨™
                
                focusedPhoto.userData.targetPos.copy(focusTargetPos);
                focusedPhoto.userData.targetScale.set(2.8, 2.8, 2.8); // æ”¾å¤§ 2.8 å€
            }
        }
        
        function resetFocusedPhoto() {
            if (focusedPhoto) {
                // æ­¸ä½åˆ°ç•¶å‰ç‹€æ…‹ï¼ˆTREE æˆ– SCATTERï¼‰çš„ç›®æ¨™ä½ç½®
                const resetPos = (currentState === 'TREE') ? focusedPhoto.userData.treePos : focusedPhoto.userData.scatterPos;
                focusedPhoto.userData.targetPos.copy(resetPos);
                focusedPhoto.userData.targetScale.copy(focusedPhoto.userData.initialScale);

                focusedPhoto.userData.isFocused = false;
                focusedPhoto = null;
            }
        }
        
        // --- ä¸»å¾ªç’° (Animate) ---

        function animate() {
            requestAnimationFrame(animate);

            // æª¢æ¸¬æ‰‹å‹¢
            detectHand();

            // ç²’å­å¹³æ»‘éæ¸¡
            updateParticles();
            
            renderer.render(scene, camera);
        }
        
        /**
         * ç²’å­ä½ç½®ã€æ—‹è½‰å’Œç¸®æ”¾çš„å¹³æ»‘éæ¸¡ (ä½¿ç”¨ Lerp)
         */
        function updateParticles() {
            const lerpFactor = 0.05; // å¹³æ»‘ä¿‚æ•¸ï¼Œå€¼è¶Šå°è¶Šå¹³æ»‘

            photoParticles.forEach(p => {
                // ä½ç½®å¹³æ»‘
                p.position.lerp(p.userData.targetPos, lerpFactor);
                
                // ç¸®æ”¾å¹³æ»‘
                p.scale.lerp(p.userData.targetScale, lerpFactor);
                
                // è®“ç…§ç‰‡é¢å‘æ”åƒæ©Ÿ (å¯é¸ï¼Œä½†å¸¸è¦‹æ–¼ç…§ç‰‡ç‰†)
                if (!p.userData.isFocused) {
                    p.lookAt(camera.position); 
                }
            });
        }

        // --- å•Ÿå‹•ç¨‹åº ---

        async function main() {
            showLoader();
            try {
                initThree();
                // å¿…é ˆå…ˆè¨­ç½® Three.jsï¼Œç„¶å¾Œæ‰èƒ½åŠ è¼‰å¸¶ç´‹ç†çš„æ¨¡å‹
                loadPhotosAndCreateParticles(); 
                
                // é€™æ˜¯ç•°æ­¥æ“ä½œï¼Œéœ€è¦ç­‰å¾…æ”åƒé ­å’Œæ¨¡å‹åŠ è¼‰
                await initMediaPipe();
                
                // å•Ÿå‹•æ¸²æŸ“å¾ªç’°
                animate();

            } catch (e) {
                console.error("åˆå§‹åŒ–å¤±æ•—:", e);
                showError("åˆå§‹åŒ–å¤±æ•—ã€‚è«‹ç¢ºèªæ”åƒé ­æ¬Šé™å’Œç¶²çµ¡é€£æ¥ã€‚");
            }
        }

        main();

    </script>
</body>
</html>
